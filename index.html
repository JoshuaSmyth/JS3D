<html>
    <body>
        <canvas id="canvas" width="320" height="200" style="scale: 2; background-color: cadetblue;"></canvas>
    </body>

    <style>
        canvas
        {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;

            transform-origin: 0 0;
            transform: scale(3);

            border: 1px solid #000000;

            z-index: 1;
        }
    </style>

    <script type="application/javascript">

    ////////////////////////////////////////////////////////////////////////////
    // Globals                                                                //
    ////////////////////////////////////////////////////////////////////////////
    var canvas = document.getElementById("canvas");
    var canvas_context = canvas.getContext("2d");
    var canvas_buffer = canvas_context.getImageData(0, 0, canvas.width, canvas.height);
    var canvas_pitch = canvas_buffer.width * 4;
    var canvas_size = canvas_buffer.width * canvas_buffer.height * 4;

    ////////////////////////////////////////////////////////////////////////////
    // Scene setup.                                                           //
    ////////////////////////////////////////////////////////////////////////////
    var viewport_size = 1;
    var projection_plane_z = 1;


    ////////////////////////////////////////////////////////////////////////////
    // Math                                                                   //
    ////////////////////////////////////////////////////////////////////////////
    var Multiply = function(k, vec) 
    {
        return [k*vec[0], k*vec[1], k*vec[2]];
    };

    var ViewportToCanvas = function(p2d)
    {
        return Pt(p2d.x * canvas.width / viewport_size, p2d.y * canvas.height / viewport_size);
    }

    var ProjectVertex = function(v)
    {
        return ViewportToCanvas(Pt(v.x * projection_plane_z / v.z, v.y * projection_plane_z / v.z));
    }

    ////////////////////////////////////////////////////////////////////////////
    // Geometry                                                               //
    ////////////////////////////////////////////////////////////////////////////
    var Pt = function(x, y, h) 
    {
        if (!(this instanceof Pt)) 
        { 
            return new Pt(x, y, h); 
        }

        this.x = x;
        this.y = y;
        this.h = h;
    };

    var Vertex = function(x, y, z)
    {
        if (!(this instanceof Vertex))
        {
            return new Vertex(x, y, z);
        }

        this.x = x;
        this.y = y;
        this.z = z;
    };

    ////////////////////////////////////////////////////////////////////////////
    // Constants                                                              //
    ////////////////////////////////////////////////////////////////////////////
    var RED = [255, 0, 0];
    var GREEN = [0, 255, 0];
    var BLUE = [0, 0, 255];


    ////////////////////////////////////////////////////////////////////////////
    // Drawing Functions                                                      //
    ////////////////////////////////////////////////////////////////////////////
    var ClearCanvas = function()
    {
        // Note: There's probably a faster way of doing this...
        for(var offset=0;offset<canvas_size;)
        {         
            canvas_buffer.data[offset++] = 0;
            canvas_buffer.data[offset++] = 255;
            canvas_buffer.data[offset++] = 255;
            canvas_buffer.data[offset++] = 255;
        }
    };

    var PutPixel = function(x, y, color) 
    {
        x = canvas.width/2 + (x | 0);
        y = canvas.height/2 - (y | 0) - 1;

        if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) 
        {
            return;
        }

        var offset = 4*x + canvas_pitch*y;
        canvas_buffer.data[offset++] = color[0];
        canvas_buffer.data[offset++] = color[1];
        canvas_buffer.data[offset++] = color[2];
        canvas_buffer.data[offset++] = 255;
    };

    var Interpolate = function(i0, d0, i1, d1) 
    {
        // TODO Write version that returns a line object instead of an array
        // preferably a line object from an object pool... ?

        if (i0 == i1) 
        {
            return [d0];
        }

        var values = [];
        var a = (d1 - d0) / (i1 - i0);
        var d = d0;
        for (var i = i0; i <= i1; i++) 
        {
            values.push(d);
            d += a;
        }

        return values;
    };

    var DrawLine = function(p0, p1, color)
    {
        // TODO Replace with Breshams? - Profile!

        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;

        if (Math.abs(dx) > Math.abs(dy))
        {
            // Horizontal(ish)
            if (dx < 0)
            {
                var swap = p0;
                p0 = p1;
                p1 = swap;
            }

            var ys = Interpolate(p0.x, p0.y, p1.x, p1.y);
            for (var x = p0.x; x <= p1.x; x++) 
            {
                PutPixel(x, ys[(x - p0.x) | 0], color);
            }
        }
        else
        {
            // Vertical(ish)
            if (dy < 0) 
            { 
                var swap = p0; 
                p0 = p1; 
                p1 = swap; 
            }

            var xs = Interpolate(p0.y, p0.x, p1.y, p1.x);
            for (var y = p0.y; y <= p1.y; y++) 
            {
                PutPixel(xs[(y - p0.y) | 0], y, color);
            }
        }
    };

    var DrawShadedTriangle = function(p0, p1, p2, color) 
    {
        // Sort the points from bottom to top.
        if (p1.y < p0.y) { var swap = p0; p0 = p1; p1 = swap; }
        if (p2.y < p0.y) { var swap = p0; p0 = p2; p2 = swap; }
        if (p2.y < p1.y) { var swap = p1; p1 = p2; p2 = swap; }

        // Compute X coordinates of the edges.
        var x01 = Interpolate(p0.y, p0.x, p1.y, p1.x);
        var h01 = Interpolate(p0.y, p0.h, p1.y, p1.h);

        var x12 = Interpolate(p1.y, p1.x, p2.y, p2.x);
        var h12 = Interpolate(p1.y, p1.h, p2.y, p2.h);

        var x02 = Interpolate(p0.y, p0.x, p2.y, p2.x);
        var h02 = Interpolate(p0.y, p0.h, p2.y, p2.h);

        // Merge the two short sides.
        x01.pop();
        var x012 = x01.concat(x12);
  
        h01.pop();
        var h012 = h01.concat(h12);

        // Determine which is left and which is right.
        var x_left, x_right;
        var h_left, h_right;
        var m = (x02.length / 2) | 0;
        if (x02[m] < x012[m]) 
        {
            x_left = x02;
            x_right = x012;
            
            h_left = h02;
            h_right = h012;
        } 
        else 
        {
            x_left = x012;
            x_right = x02;

            h_left = h012; 
            h_right = h02;
        }

        // Draw horizontal segments.
        for (var y = p0.y; y <= p2.y; y++) 
        {
            var xl = x_left[y - p0.y] | 0;
            var xr = x_right[y - p0.y] | 0;
            var h_segment = Interpolate(xl, h_left[y - p0.y], xr, h_right[y - p0.y]);

            for (var x = xl; x <= xr; x++) 
            {
                PutPixel(x, y, Multiply(h_segment[x - xl], color));
            }
        }
    };

    var DrawFilledTriangle = function(p0, p1, p2, color) 
    {
        // Sort the points from bottom to top.
        if (p1.y < p0.y) { var swap = p0; p0 = p1; p1 = swap; }
        if (p2.y < p0.y) { var swap = p0; p0 = p2; p2 = swap; }
        if (p2.y < p1.y) { var swap = p1; p1 = p2; p2 = swap; }

        // Compute X coordinates of the edges.
        var x01 = Interpolate(p0.y, p0.x, p1.y, p1.x);
        
        var x12 = Interpolate(p1.y, p1.x, p2.y, p2.x);
        
        var x02 = Interpolate(p0.y, p0.x, p2.y, p2.x);

        // Merge the two short sides.
        x01.pop();
        var x012 = x01.concat(x12);

        // Determine which is left and which is right.
        var x_left, x_right;
        var m = (x02.length / 2) | 0;
        if (x02[m] < x012[m]) 
        {
            x_left = x02;
            x_right = x012;
        } 
        else 
        {
            x_left = x012;
            x_right = x02;
        }

        // Draw horizontal segments.
        for (var y = p0.y; y <= p2.y; y++) 
        {
            for (var x = x_left[y - p0.y]; x <= x_right[y - p0.y]; x++) 
            {
                PutPixel(x, y, color);
            }
        }
    };

    var DrawTriangleWireframe = function(p0, p1, p2, color) 
    {
        DrawLine(p0, p1, color);
        DrawLine(p1, p2, color);
        DrawLine(p0, p2, color);
    };

    // Main Functions
    var UpdateCanvas = function() 
    {
        canvas_context.putImageData(canvas_buffer, 0, 0);
    };

    var render = function()
    {
        x+=0.01;
        var d = 50 * Math.sin(x)
        var p0 = Pt(-80+d, -80, 0.25);
        var p1 = Pt(80, 50, 0.5);
        var p2 = Pt(20, 80, 0.75);

        //DrawFilledTriangle(p0, p1, p2, [0, 255, 0]);

        // Note: ATM only triangle color with shading, not shading per vertex.
        // But could be used as input into a dither stage?
        DrawShadedTriangle(p0, p1, p2, [0, 255, 0]);        
        DrawTriangleWireframe(p0, p1, p2, [r, g, b]);
    };

    var renderPerspectiveCube = function()
    {
        x+=0.01;
        var d = 2 * Math.sin(x)

        var vA = Vertex(d + -0.5, -0.5, 5);
        var vB = Vertex(d + -0.5, 0.5, 5);
        var vC = Vertex(d +  0.5, 0.5, 5);
        var vD = Vertex(d +  0.5, -0.5, 5);

        var vAb = Vertex(d + -0.5, -0.5, 6);
        var vBb = Vertex(d + -0.5, 0.5, 6);
        var vCb = Vertex(d +  0.5, 0.5, 6);
        var vDb = Vertex(d +  0.5, -0.5, 6);

        DrawLine(ProjectVertex(vA), ProjectVertex(vB), BLUE);
        DrawLine(ProjectVertex(vB), ProjectVertex(vC), BLUE);
        DrawLine(ProjectVertex(vC), ProjectVertex(vD), BLUE);
        DrawLine(ProjectVertex(vD), ProjectVertex(vA), BLUE);

        DrawLine(ProjectVertex(vAb), ProjectVertex(vBb), RED);
        DrawLine(ProjectVertex(vBb), ProjectVertex(vCb), RED);
        DrawLine(ProjectVertex(vCb), ProjectVertex(vDb), RED);
        DrawLine(ProjectVertex(vDb), ProjectVertex(vAb), RED);

        DrawLine(ProjectVertex(vA), ProjectVertex(vAb), GREEN);
        DrawLine(ProjectVertex(vB), ProjectVertex(vBb), GREEN);
        DrawLine(ProjectVertex(vC), ProjectVertex(vCb), GREEN);
        DrawLine(ProjectVertex(vD), ProjectVertex(vDb), GREEN);
    };

    var r = 0;
    var g = 0;
    var b = 0;
    var x = 0;
    function update()
    {
        window.requestAnimationFrame(update); 
        
        ClearCanvas();

        render();
        renderPerspectiveCube();

        UpdateCanvas();
    };

    function init()
    {
        window.requestAnimationFrame(update);
    };

    init();

    </script>
</html>
